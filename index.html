<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>tiny_render_js</title>
    <style>
        canvas {
            border: 1px black solid;
        }
    </style>
    <script src="math3d.js"></script>
</head>
<body>
    <canvas id="id-canvas" width="400" height="400"></canvas>
    <canvas id="z-canvas" width="400" height="400"></canvas>
<script>
var __main__ = function() {
    var log = console.log.bind(console)
    var machine = {}
    machine.event = []
    machine.run = function() {
        machine.event.push(1)
        if (machine.event.length == 2) {
            machine.render()
        }
    }

    var canvas = document.querySelector('#id-canvas')
    var ctx = canvas.getContext('2d')

    var tex = new Image()
    tex.src = 'tex.jpg'
    var texCanvas = document.createElement('canvas')
    document.body.appendChild(texCanvas)
    var texCtx = texCanvas.getContext('2d')
    var pixelArray = {}
    pixelArray.pixelXY = function(x, y) {
        i = x * canvas.width + y
        var r = pixelArray.data.data[i * 4 + 0]
        var g = pixelArray.data.data[i * 4 + 1]
        var b = pixelArray.data.data[i * 4 + 2]
        return [r, g, b]
    }

    pixelArray.pixelUV = function(u, v) {
        var x = Math.floor(u * texCanvas.width)
        var y = Math.floor(v * texCanvas.height)
        return pixelArray.pixelXY(x, y)
        
    }
    tex.onload = function() {
        texCanvas.width = tex.width
        texCanvas.height = tex.height
        texCtx.drawImage(tex, 0, 0, tex.width, tex.height)
        pixelArray.data = texCtx.getImageData(0, 0, tex.width, tex.height)
        machine.run()
    }

    var genZBuffer = function() {
        var zBuffer = []
        for (var i = 0; i < canvas.height; i++) {
            zBuffer[i] = []
            for (var j = 0; j < canvas.width; j++) {
                zBuffer[i][j] = Number.NEGATIVE_INFINITY
            }
        }
        return zBuffer
    }
    

    var drawPoint = function(p) {
        ctx.fillRect(p[0], p[1], 1, 1)
    }

    var drawLine = function(p0, p1, color) {
        var p0 = p0.slice()
        var p1 = p1.slice()

        var swap = function(p0, p1) {
            var t = p0[0]
            p0[0] = p1[0]
            p1[0] = t
            t = p0[1]
            p0[1] = p1[1]
            p1[1] = t
        }

        ctx.fillStyle = color
        var steep = false
        if (Math.abs(p0[0] - p1[0]) < Math.abs(p0[1] - p1[1])) {
            steep = true
        }
        if (steep) {
            if (p0[1] > p1[1]) {
                swap(p0, p1)
            }
            for (var y = p0[1]; y < p1[1]; y += 1) {
                var i = (y - p0[1]) / (p1[1] - p0[1])
                x = p0[0] + (p1[0] - p0[0]) * i
                drawPoint([x, y])
            }
        } else {
            if (p0[0] > p1[0]) {
                swap(p0, p1)
            }
            for (var x = p0[0]; x < p1[0]; x += 1) {
                var i = (x - p0[0]) / (p1[0] - p0[0])
                y = p0[1] + (p1[1] - p0[1]) * i
                drawPoint([x, y])
            }
        }
    }
    var convertToScreen = function(p) {
        var p = p.slice()
        p[0] = parseInt((p[0] + 1) / 2 * canvas.width)
        p[1] = parseInt((1 - (p[1] + 1) / 2) * canvas.height)
        return p
    } 

    var model = {}
    model.pos = [
    ]
    model.face = [
    ]
    model.drawWireframe = function() {
        for (var f = 0; f < model.face.length; f++) {
            var p0 =  convertToScreen(model.pos[model.face[f][0]])
            var p1 =  convertToScreen(model.pos[model.face[f][1]])
            var p2 =  convertToScreen(model.pos[model.face[f][2]])
            drawLine(p0, p1, 'red')
            drawLine(p1, p2, 'green')
            drawLine(p2, p0, 'blue')
        }
    }

    model.drawTriangle = function() {
        var zBuffer = genZBuffer()
        for (var f = 0; f < model.face.length; f++) {
            var wp0 =  model.pos[model.face[f][0][0]]
            var wp1 =  model.pos[model.face[f][1][0]]
            var wp2 =  model.pos[model.face[f][2][0]]

            var n = normalOfTriangle(wp0, wp1, wp2)
            var cosValue = dot(n, [0, 0, 1])
            if (cosValue < 0) {
                continue
            }
            
            // gamma correct
            cosValue = Math.pow(cosValue, 1/2.2)

            var p0 =  convertToScreen(wp0)
            var p1 =  convertToScreen(wp1)
            var p2 =  convertToScreen(wp2)

            xl = [p0[0], p1[0], p2[0]]
            yl = [p0[1], p1[1], p2[1]]

            var left = Math.min(...xl)
            var right = Math.max(...xl)
            var up = Math.min(...yl)
            var bottom = Math.max(...yl)
            var r = Math.round(180 * cosValue)
            var g = Math.round(180 * cosValue)
            var b = Math.round(180 * cosValue)


            ctx.fillStyle = 'rgb(' + r + ',' + g+ ',' + b + ')'


            for (var x = left; x < right + 1; x++) {
                if (x < 0 || x >= canvas.width) {
                    continue
                }
                for (var y = up; y < bottom + 1; y++) {
                    if (y < 0 || y >= canvas.height) {
                        continue
                    }
                    var b = barycentric(p0, p1, p2, [x, y])
                    if (anyNegative(b)) {
                        continue
                    }
                    var z = b[0] * wp0[2] + b[1] * wp1[2] + b[2] * wp2[2]
                    if (z <= zBuffer[x][y]) {
                        continue
                    }
                    zBuffer[x][y] = z
                    var u = Math.floor(model.uv[model.face[f][0][1]][0] * texCanvas.width)
                    var v = Math.floor(model.uv[model.face[f][0][1]][1] * texCanvas.height)
                    // var u = model.uv[model.face[f][0][1]][0]
                    // var v = model.uv[model.face[f][0][1]][1]
                    // texPixel = pixelArray.pixelUV(u, v)
                    // hot
                    texPixel = texCtx.getImageData(u, v, 1, 1)

                    var r = Math.round(texPixel.data[0] * cosValue)
                    var g = Math.round(texPixel.data[1] * cosValue)
                    var b = Math.round(texPixel.data[2] * cosValue)
                    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')'
                    drawPoint([x, y])
                }
            }
        }
        var zCanvas = document.querySelector('#z-canvas')
        var zCtx = zCanvas.getContext('2d')
        zCtx.fillStyle = 'Magenta'
        for (var i = 0; i < canvas.height; i++) {
            for (var j = 0; j < canvas.width; j++) {
                if (zBuffer[i][j] == Number.NEGATIVE_INFINITY) {
                    zCtx.fillStyle = 'Magenta'
                    zCtx.fillRect(i, j, 1, 1)
                } else {
                    var intensity = (zBuffer[i][j] + 1) / 2
                    intensity = Math.min(1, Math.max(0, intensity))
                    var r = Math.round(255 * intensity)
                    var g = Math.round(255 * intensity)
                    var b = Math.round(255 * intensity)
                    zCtx.fillStyle = 'rgb(' + r + ',' + g+ ',' + b + ')'
                    zCtx.fillRect(i, j, 1, 1)
                }
            }
        }
    }
    
    machine.render = function() {
        model.drawTriangle()
    }

    var xhr = new XMLHttpRequest()
    xhr.onreadystatechange = function() {
        if (this.readyState != 4) {
            return
        }
        var obj = this.responseText
        obj = obj.split('\n')
        pos = []
        face = []
        uv = []
        normal = []
        for (var i = 0; i < obj.length; i++) {

            var l = obj[i]
            if (l.startsWith('v ')) {
                l = l.split(' ')
                pos.push([parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3])])
            } else if (l.startsWith('vt ')) {
                l = l.split(' ')
                uv.push([parseFloat(l[1]), 1 - parseFloat(l[2])])
            } else if (l.startsWith('vn ')) {
                l = l.split(' ')
                normal.push([parseFloat(l[1]), parseFloat(l[2]), parseFloat(l[3])])
            } else if (l.startsWith('f ')) {
                l = l.split(' ')
                var f = []
                for (var fi = 1; fi <= 3; fi++) {
                    var p = []
                    for (var j = 0; j < 3; j++) {
                        p.push(parseInt(l[fi].split('/')[j]) - 1)
                    }
                    f.push(p)
                }
                face.push(f)
            }
        }

        model.pos = pos
        model.face = face
        model.uv = uv
        model.noraml = normal
        model.face = face

        machine.run()
    }
    xhr.open('GET', 'monkey.obj')
    xhr.send()
}
__main__()
</script>
</body>
</html>